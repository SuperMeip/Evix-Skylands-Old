using System;
using UnityEngine;
using Blocks;
using System.Collections.Generic;

/// <summary>
/// A level generated to look like floating islands, generated by column
/// </summary>
public class Island : Level {

  /// <summary>
  /// The location of chunk columns in this island that have already been generated
  /// </summary>
  public bool[,] generatedChunkColumnLocations;

  /// <summary>
  /// Used for terrain lerp part 1
  /// </summary>
  protected float TerrainFrequencyOne = 50.0f;

  /// <summary>
  /// Used for terrain lerp part 2
  /// </summary>
  protected float TerrainFrequencyTwo = 60.0f;

  /// <summary>
  /// Used for terrain lerp part 3
  /// </summary>
  protected float TerrainFrequencyThree = 40.0f;

  /// <summary>
  /// Multiplier for blocks above the base island height
  /// </summary>
  protected float TopHeightMultiplier = 15.0f;
  
  /// <summary>
  /// Multiplier for blocks below the base island height
  /// </summary>
  protected float BottomHeightMultiplier = 80.0f;

  /// <summary>
  /// How solid a column has to be to form a column
  /// </summary>
  protected float SolidityThreshold = 0.35f;

  /// <summary>
  /// How solid a column has to be to form a column of liquid
  /// </summary>
  protected float WaterThreshold = 0.25f;

  /// <summary>
  /// How solid a column has to be to form a column of liquid
  /// </summary>
  protected float StoneChance = 0.30f;

  /// <summary>
  /// Further curtails the wter to offset it from the land
  /// </summary>
  protected float WaterFallOffFactor = 0.0f;

  /// <summary>
  /// The base height of the island
  /// </summary>
  protected int BaseIslandHeight = 64;

  /// <summary>
  /// Create a new island at the nexus location in the world
  /// </summary>
  /// <param name="world"></param>
  /// <param name="location"></param>
  public Island(World world, Coordinate location) : base (world, location) {
    generatedChunkColumnLocations = new bool[widthInChunks, depthInChunks];
  }

  /// <summary>
  /// Generate only in a radius around one chunk, ignores already generated chunks.
  /// </summary>
  /// <param name="chunk"></param>
  /// <param name="radius">the number of chunks around the chunk at this location to generate</param>
  public void generateAroundChunk(Coordinate location, int radius) {
    Coordinate chunkLocation = new Coordinate(0, 0, 0);
    for (chunkLocation.x = location.x - radius; chunkLocation.x <= location.x + radius; chunkLocation.x++) {
      for (chunkLocation.z = location.z - radius; chunkLocation.z <= location.z + radius; chunkLocation.z++) {
        generateForChunk(getChunk(chunkLocation));
      }
    }
  }

  /// <summary>
  /// Generate for the column of chunks this chunk is in in this island
  /// </summary>
  /// <param name="chunk"></param>
  protected void generateForChunk(Chunk chunk) {
    if (chunk == null) {
      return;
    }
    if (chunk.level == this && !generatedChunkColumnLocations[chunk.location.x, chunk.location.z]) {
      for (int x = 0; x < Chunk.CHUNK_DIAMETER; x++) {
        for (int z = 0; z < Chunk.CHUNK_DIAMETER; z++) {
          int islandX = chunk.location.x * Chunk.CHUNK_DIAMETER + x;
          int islandZ = chunk.location.z * Chunk.CHUNK_DIAMETER + z;
          generateColumn(islandX, islandZ);
        }
      }
    }
    generatedChunkColumnLocations[chunk.location.x, chunk.location.z] = true;
  }

  /// <summary>
  /// A threaded job to generate a single column of chunks.
  /// </summary>
  public class GenerateChunkColumnThreaded : ThreadedJob {
    /// <summary>
    /// The x and z of the chunk column to generate
    /// </summary>
    public Chunk chunk;

    /// <summary>
    /// The island to generate it for.
    /// </summary>
    public Island island;

    /// <summary>
    /// The queue to output this data to
    /// </summary>
    public List<Coordinate> outputQueue;

    /// <summary>
    /// Generate the column of chunks for the given location in the given island
    /// </summary>
    protected override void ThreadFunction() {
      if (island != null && chunk != null) {
        island.generateForChunk(chunk);
        if (outputQueue != null) {
          outputQueue.Add(chunk.location);
        }
      }
    }
  }

  /// <summary>
  /// Generate a column of terrain on this island at point x, z
  /// </summary>
  /// <param name="x"></param>
  /// <param name="z"></param>
  private void generateColumn(int x, int z) {
    System.Random random = new System.Random();
    float perlinNoiseResultOne = Mathf.PerlinNoise(
      (x + seed) / TerrainFrequencyOne,
      (z + seed) / TerrainFrequencyOne
    );

    float perlinNoiseResultTwo = Mathf.PerlinNoise(
      (x + seed) / TerrainFrequencyTwo,
      (z + seed) / TerrainFrequencyTwo
    );

    float perlinNoiseResultThree = Mathf.PerlinNoise(
      (x + seed) / TerrainFrequencyThree,
      (z + seed) / TerrainFrequencyThree
    );

    float fallOffFactor = (float)getFalloffFactor(new Coordinate(x, z));

    float finalNoiseResult = Mathf.Lerp(
      perlinNoiseResultOne,
      perlinNoiseResultTwo,
      perlinNoiseResultThree
    ) - fallOffFactor;

    float waterColumnResult = 1 - Mathf.Lerp(
      perlinNoiseResultTwo,
      perlinNoiseResultThree,
      perlinNoiseResultOne
    ) - fallOffFactor - WaterFallOffFactor;

    if (finalNoiseResult >= SolidityThreshold || waterColumnResult >= WaterThreshold) {

      int topColumnHeight = (int)((finalNoiseResult - SolidityThreshold) * TopHeightMultiplier);
      int bottomColumnHeight = (int)((finalNoiseResult - SolidityThreshold) * BottomHeightMultiplier);
      int bottomWaterColumnHeight = (int)((waterColumnResult - WaterThreshold) * BottomHeightMultiplier);

      int greatestDepth = bottomWaterColumnHeight > bottomColumnHeight ? bottomWaterColumnHeight : bottomColumnHeight;
      int greatestHeight = 0 > topColumnHeight ? 0 : topColumnHeight;

      for (int y = BaseIslandHeight - greatestDepth; y <= BaseIslandHeight + greatestHeight; y++) {
        Block newBlock;
        Chunk blockChunk = getChunk(new Coordinate(x / Chunk.CHUNK_DIAMETER, y / Chunk.CHUNK_HEIGHT, z / Chunk.CHUNK_DIAMETER));
        blockChunk.hasBeenGenerated = true;
        Coordinate localBlockLocation = new Coordinate(x, y, z).trimmed;
        if (topColumnHeight + bottomColumnHeight < 0) {
          newBlock = new Water(localBlockLocation, blockChunk);
        }
        // small columns of 1 or less should be sand, beaches
        else if (topColumnHeight + bottomColumnHeight <= 1 && y <= BaseIslandHeight) {
          newBlock = new Sand(localBlockLocation, blockChunk);
        }
        // if it's on the top of a dirt column it's grass
        else if (y == BaseIslandHeight + topColumnHeight) {
          newBlock = new Grass(localBlockLocation, blockChunk);
        }
        // if it's in a dirt colulumn above the base island height it's dirt
        else if (y >= BaseIslandHeight) {
          newBlock = new Dirt(localBlockLocation, blockChunk);
        }
        // if it's below the base island height it could either be a stone or a dirt
        else {
          // @todo: fix this
          newBlock = random.Next(BaseIslandHeight - greatestDepth, BaseIslandHeight + greatestHeight) <= y
            ? Block.make(localBlockLocation, blockChunk, Block.Type.dirt)
            : Block.make(localBlockLocation, blockChunk, Block.Type.stone);
        }
        blockChunk.updateBlock(newBlock);
      }
    }
  }

  /// <summary>
  /// Get the fall off factor of the island.
  /// </summary>
  /// <param name="location"></param>
  /// <returns></returns>
  private double getFalloffFactor(Coordinate location) {
    Coordinate centerPoint = new Coordinate(width / 2, depth / 2);
    double distance = width / 2 - centerPoint.distance(location);
    return 1 / (1 + Math.Pow(Math.E, (distance * 12 / (width / 2))));
  }
}
