using System;
using UnityEngine;
using Blocks;

/// <summary>
/// A level generated to look like floating islands, generated by column
/// </summary>
public class Island : Level {

  /// <summary>
  /// Used for terrain lerp part 1
  /// </summary>
  protected static float TerrainFrequencyOne = 50.0f;

  /// <summary>
  /// Used for terrain lerp part 2
  /// </summary>
  protected static float TerrainFrequencyTwo = 60.0f;

  /// <summary>
  /// Used for terrain lerp part 3
  /// </summary>
  protected static float TerrainFrequencyThree = 40.0f;

  /// <summary>
  /// Multiplier for blocks above the base island height
  /// </summary>
  protected static float TopHeightMultiplier = 15.0f;

  /// <summary>
  /// Multiplier for blocks below the base island height
  /// </summary>
  protected static float BottomHeightMultiplier = 80.0f;

  /// <summary>
  /// How solid a column has to be to form a column
  /// </summary>
  protected static float SolidityThreshold = 0.35f;

  /// <summary>
  /// How solid a column has to be to form a column of liquid
  /// </summary>
  protected static float WaterThreshold = 0.25f;

  /// <summary>
  /// How solid a column has to be to form a column of liquid
  /// </summary>
  protected static float StoneChance = 0.30f;

  /// <summary>
  /// Further curtails the wter to offset it from the land
  /// </summary>
  protected static float WaterFallOffFactor = 0.0f;

  /// <summary>
  /// The base height of the island
  /// </summary>
  protected static int BaseIslandHeight = 64;

  /// <summary>
  /// The location of chunk columns in this island that have already been generated
  /// </summary>
  bool[,] generatedChunkColumnLocations;

  /// <summary>
  /// Create a new island at the nexus location in the world
  /// </summary>
  /// <param name="world"></param>
  /// <param name="location"></param>
  public Island(World world, Coordinate location) : base (world, location) {
    generatedChunkColumnLocations = new bool[widthInChunks, depthInChunks];
  }

  /// <summary>
  /// Generate all of the chunks at once
  /// </summary>
  public override void generateAllChunks() {
    forEach((Chunk chunk) => {
      if (chunk.location.y == 0) {
        generateChunkColumn(chunk);
      }
    });
    isFinishedGenerating = true;
  }

  /// <summary>
  /// enqueue the block and all chunks in it's column for generation
  /// </summary>
  /// <param name="chunk">The chunk to use the location for for genration</param>
  /// <returns></returns>
  public override ThreadedJob queueChunkForGeneration(Chunk chunk) {
    if (chunk == null) {
      return null;
    }
    if (!columnHasBeenGenerated(chunk.location)) {
      GenerateChunkColumnThreadedJob newChunkGenerationJob = new GenerateChunkColumnThreadedJob() {
        chunk = chunk
      };
      return newChunkGenerationJob;
    }
    return null;
  }

  /// <summary>
  /// enqueue the block and all chunks in it's column for generation
  /// </summary>
  /// <param name="chunk">the location for for genration</param>
  /// <returns></returns>
  public ThreadedJob queueChunkForGeneration(Coordinate chunkLocation) {
    if (!chunkLocation.isInitialized) {
      return null;
    }
    return queueChunkForGeneration(getChunk(chunkLocation));
  }

  /// <summary>
  /// Generate only in a radius around one chunk, ignores already generated chunks.
  /// </summary>
  /// <param name="chunk"></param>
  /// <param name="radius">the number of chunks around the chunk at this location to generate</param>
  public void generateAroundChunk(Coordinate location, int radius) {
    Coordinate chunkLocation = new Coordinate(0, 0, 0);
    for (chunkLocation.x = location.x - radius; chunkLocation.x <= location.x + radius; chunkLocation.x++) {
      for (chunkLocation.z = location.z - radius; chunkLocation.z <= location.z + radius; chunkLocation.z++) {
        queueChunkForGeneration(getChunk(chunkLocation));
      }
    }
  }

  ///<summary>
  /// Generate terain for all of the chunks in this island
  /// </summary>
  public void generateForAllChunks() {
    forEach((Chunk chunk) => queueChunkForGeneration(chunk));
  }

  /// <summary>
  /// Check if a column of chunks in this island has been generated
  /// </summary>
  /// <param name="columnLocation">the (x,z) of the column</param>
  /// <returns>if this column of chunks has been generated</returns>
  public bool columnHasBeenGenerated(Coordinate columnLocation) {
    if (columnLocation.isWithinChunkBounds) {
      return generatedChunkColumnLocations[columnLocation.x, columnLocation.z];
    }
    return false;
  }

  /// <summary>
  /// Set the colum as has been generated
  /// </summary>
  /// <param name="columnLocation"></param>
  public void setColumnGenerated(Coordinate columnLocation) {
    if (columnLocation.isWithinChunkBounds) {
      generatedChunkColumnLocations[columnLocation.x, columnLocation.z] = true;
    }
  }

  /// <summary>
  /// A threaded job to generate a single column of chunks.
  /// </summary>
  public class GenerateChunkColumnThreadedJob : ThreadedJob {

    /// <summary>
    /// A chunk at the location to render the column of chunks for
    /// </summary>
    public Chunk chunk;

    /// <summary>
    /// Generate the column of chunks for the given location in the given island
    /// </summary>
    protected override void ThreadFunction() {
      generateChunkColumn(chunk);
    }
  }

  /// <summary>
  /// Generate columns of blocks at the chunk x, z
  /// </summary>
  /// <param name="chunk"></param>
  static void generateChunkColumn(Chunk chunk) {
    for (int x = 0; x < Chunk.CHUNK_DIAMETER; x++) {
      for (int z = 0; z < Chunk.CHUNK_DIAMETER; z++) {
        int islandX = chunk.location.x * Chunk.CHUNK_DIAMETER + x;
        int islandZ = chunk.location.z * Chunk.CHUNK_DIAMETER + z;
        generateColumn(chunk, islandX, islandZ);
      }
    }
    Island island = chunk.level as Island;
    island.setColumnGenerated(chunk.location);
  }

  /// <summary>
  /// Generate a column of terrain on this island at point x, z
  /// </summary>
  /// <param name="x"></param>
  /// <param name="z"></param>
  static void generateColumn(Chunk chunk, int x, int z) {
    int seed = chunk.level.seed;
    System.Random random = new System.Random();
    float perlinNoiseResultOne = Mathf.PerlinNoise(
      (x + seed) / TerrainFrequencyOne,
      (z + seed) / TerrainFrequencyOne
    );

    float perlinNoiseResultTwo = Mathf.PerlinNoise(
      (x + seed) / TerrainFrequencyTwo,
      (z + seed) / TerrainFrequencyTwo
    );

    float perlinNoiseResultThree = Mathf.PerlinNoise(
      (x + seed) / TerrainFrequencyThree,
      (z + seed) / TerrainFrequencyThree
    );

    float fallOffFactor = (float)getFalloffFactor(new Coordinate(x, z));

    float finalNoiseResult = Mathf.Lerp(
      perlinNoiseResultOne,
      perlinNoiseResultTwo,
      perlinNoiseResultThree
    ) - fallOffFactor;

    float waterColumnResult = 1 - Mathf.Lerp(
      perlinNoiseResultTwo,
      perlinNoiseResultThree,
      perlinNoiseResultOne
    ) - fallOffFactor - WaterFallOffFactor;

    if (finalNoiseResult >= SolidityThreshold || waterColumnResult >= WaterThreshold) {

      int topColumnHeight = (int)((finalNoiseResult - SolidityThreshold) * TopHeightMultiplier);
      int bottomColumnHeight = (int)((finalNoiseResult - SolidityThreshold) * BottomHeightMultiplier);
      int bottomWaterColumnHeight = (int)((waterColumnResult - WaterThreshold) * BottomHeightMultiplier);

      int greatestDepth = bottomWaterColumnHeight > bottomColumnHeight ? bottomWaterColumnHeight : bottomColumnHeight;
      int greatestHeight = 0 > topColumnHeight ? 0 : topColumnHeight;

      for (int y = BaseIslandHeight - greatestDepth; y <= BaseIslandHeight + greatestHeight; y++) {
        BlockType blockType;
        Chunk blockChunk = chunk.level.getChunk(new Coordinate(x / Chunk.CHUNK_DIAMETER, y / Chunk.CHUNK_HEIGHT, z / Chunk.CHUNK_DIAMETER));
        Coordinate localBlockLocation = new Coordinate(x, y, z).trimmed;
        if (topColumnHeight + bottomColumnHeight < 0) {
          blockType = BlockTypes.Water;
        }
        else if (topColumnHeight + bottomColumnHeight <= 1 && y <= BaseIslandHeight) {
          // small columns of 1 or less should be sand, beaches
          blockType = BlockTypes.Sand;
        }
        else if (y == BaseIslandHeight + topColumnHeight) {
          // if it's on the top of a dirt column it's grass
          blockType = BlockTypes.Grass;
        }
        else if (y >= BaseIslandHeight) {
          // if it's in a dirt colulumn above the base island height it's dirt
          blockType = BlockTypes.Dirt;
        }
        else {
          // if it's below the base island height it could either be a stone or a dirt
          // @todo: fix this
          blockType = random.Next(BaseIslandHeight - greatestDepth, BaseIslandHeight + greatestHeight) <= y
            ? BlockTypes.Dirt
            : BlockTypes.Stone;
        }
        blockChunk.hasBeenGenerated = true;
        blockChunk.updateBlock(new Block(localBlockLocation, blockChunk, blockType));
      }
    }
  }

  /// <summary>
  /// Get the fall off factor of the island.
  /// </summary>
  /// <param name="location"></param>
  /// <returns></returns>
  static double getFalloffFactor(Coordinate location) {
    Coordinate centerPoint = new Coordinate(Width / 2, Depth / 2);
    double distance = Width / 2 - centerPoint.distance(location);
    return 1 / (1 + Math.Pow(Math.E, (distance * 12 / (Width / 2))));
  }
}
